@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchGetChannelStreamSchedule
	


## 
## #/components/schemas/GetChannelStreamScheduleResponse
class Response extends TwitchData:

	## The broadcaster’s streaming schedule.
	@export var data: ResponseData:
		set(val): 
			data = val
			track_data(&"data", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_data: ResponseData) -> Response:
		var response: Response = Response.new()
		response.data = _data
		return response
	
	
	static func from_json(d: Dictionary) -> Response:
		var result: Response = Response.new()
		if d.get("data", null) != null:
			result.data = ResponseData.from_json(d["data"])
		return result
	


## The broadcaster’s streaming schedule.
## #/components/schemas/GetChannelStreamScheduleResponse/Data
class ResponseData extends TwitchData:

	## The list of broadcasts in the broadcaster’s streaming schedule.
	@export var segments: Array[TwitchChannelStreamScheduleSegment]:
		set(val): 
			segments = val
			track_data(&"segments", val)
	
	## The ID of the broadcaster that owns the broadcast schedule.
	@export var broadcaster_id: String:
		set(val): 
			broadcaster_id = val
			track_data(&"broadcaster_id", val)
	
	## The broadcaster’s display name.
	@export var broadcaster_name: String:
		set(val): 
			broadcaster_name = val
			track_data(&"broadcaster_name", val)
	
	## The broadcaster’s login name.
	@export var broadcaster_login: String:
		set(val): 
			broadcaster_login = val
			track_data(&"broadcaster_login", val)
	
	## The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	@export var vacation: ResponseVacation:
		set(val): 
			vacation = val
			track_data(&"vacation", val)
	
	## The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	@export var pagination: ResponsePagination:
		set(val): 
			pagination = val
			track_data(&"pagination", val)
	
	
	
	## Constructor with all required fields.
	static func create(_segments: Array[TwitchChannelStreamScheduleSegment], _broadcaster_id: String, _broadcaster_name: String, _broadcaster_login: String, _vacation: ResponseVacation) -> ResponseData:
		var response_data: ResponseData = ResponseData.new()
		response_data.segments = _segments
		response_data.broadcaster_id = _broadcaster_id
		response_data.broadcaster_name = _broadcaster_name
		response_data.broadcaster_login = _broadcaster_login
		response_data.vacation = _vacation
		return response_data
	
	
	static func from_json(d: Dictionary) -> ResponseData:
		var result: ResponseData = ResponseData.new()
		if d.get("segments", null) != null:
			for value in d["segments"]:
				result.segments.append(TwitchChannelStreamScheduleSegment.from_json(value))
		if d.get("broadcaster_id", null) != null:
			result.broadcaster_id = d["broadcaster_id"]
		if d.get("broadcaster_name", null) != null:
			result.broadcaster_name = d["broadcaster_name"]
		if d.get("broadcaster_login", null) != null:
			result.broadcaster_login = d["broadcaster_login"]
		if d.get("vacation", null) != null:
			result.vacation = ResponseVacation.from_json(d["vacation"])
		if d.get("pagination", null) != null:
			result.pagination = ResponsePagination.from_json(d["pagination"])
		return result
	
	
	
	func _has_pagination() -> bool:
		if pagination == null: return false
		if pagination.cursor == null || pagination.cursor == "": return false
		return true
	
	var _next_page: Callable
	var _cur_iter: int = 0
	
	
	func next_page() -> Response:
		var response: Response = await _next_page.call()
		_cur_iter = 0
		_next_page = response.data._next_page
		segments = response.data.segments
		broadcaster_id = response.data.broadcaster_id
		broadcaster_name = response.data.broadcaster_name
		broadcaster_login = response.data.broadcaster_login
		vacation = response.data.vacation
		pagination = response.data.pagination
	
		return response
	
	
	func _iter_init(iter: Array) -> bool:
		if segments.is_empty(): return false
		iter[0] = segments[0]
		_cur_iter = 1
		return true
		
		
	func _iter_next(iter: Array) -> bool:
		if segments.size() > _cur_iter:
			iter[0] = segments[_cur_iter]
			_cur_iter += 1
		elif not _has_pagination(): 
			return false
		return true
		
		
	func _iter_get(iter: Variant) -> Variant:
		if segments.size() - 1 == _cur_iter && _has_pagination():
			await next_page()
		return iter


## The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
## #/components/schemas/GetChannelStreamScheduleResponse/Data/Vacation
class ResponseVacation extends TwitchData:

	## The UTC date and time (in RFC3339 format) of when the broadcaster’s vacation starts.
	@export var start_time: String:
		set(val): 
			start_time = val
			track_data(&"start_time", val)
	
	## The UTC date and time (in RFC3339 format) of when the broadcaster’s vacation ends.
	@export var end_time: String:
		set(val): 
			end_time = val
			track_data(&"end_time", val)
	
	
	
	## Constructor with all required fields.
	static func create(_start_time: String, _end_time: String) -> ResponseVacation:
		var response_vacation: ResponseVacation = ResponseVacation.new()
		response_vacation.start_time = _start_time
		response_vacation.end_time = _end_time
		return response_vacation
	
	
	static func from_json(d: Dictionary) -> ResponseVacation:
		var result: ResponseVacation = ResponseVacation.new()
		if d.get("start_time", null) != null:
			result.start_time = d["start_time"]
		if d.get("end_time", null) != null:
			result.end_time = d["end_time"]
		return result
	


## The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
## #/components/schemas/GetChannelStreamScheduleResponse/Data/Pagination
class ResponsePagination extends TwitchData:

	## The cursor used to get the next page of results. Set the request’s _after_ query parameter to this value.
	@export var cursor: String:
		set(val): 
			cursor = val
			track_data(&"cursor", val)
	
	
	
	## Constructor with all required fields.
	static func create() -> ResponsePagination:
		var response_pagination: ResponsePagination = ResponsePagination.new()
		return response_pagination
	
	
	static func from_json(d: Dictionary) -> ResponsePagination:
		var result: ResponsePagination = ResponsePagination.new()
		if d.get("cursor", null) != null:
			result.cursor = d["cursor"]
		return result
	


## All optional parameters for TwitchAPI.get_channel_stream_schedule
## #/components/schemas/GetChannelStreamScheduleOpt
class Opt extends TwitchData:

	## The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	@export var id: Array[String]:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## The UTC date and time that identifies when in the broadcaster’s schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, `2022-09-01T00:00:00Z`).
	@export var start_time: String:
		set(val): 
			start_time = val
			track_data(&"start_time", val)
	
	## Not supported.
	@export var utc_offset: String:
		set(val): 
			utc_offset = val
			track_data(&"utc_offset", val)
	
	## The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20.
	@export var first: int:
		set(val): 
			first = val
			track_data(&"first", val)
	
	## The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	@export var after: String:
		set(val): 
			after = val
			track_data(&"after", val)
	
	
	
	## Constructor with all required fields.
	static func create() -> Opt:
		var opt: Opt = Opt.new()
		return opt
	
	
	static func from_json(d: Dictionary) -> Opt:
		var result: Opt = Opt.new()
		if d.get("id", null) != null:
			for value in d["id"]:
				result.id.append(value)
		if d.get("start_time", null) != null:
			result.start_time = d["start_time"]
		if d.get("utc_offset", null) != null:
			result.utc_offset = d["utc_offset"]
		if d.get("first", null) != null:
			result.first = d["first"]
		if d.get("after", null) != null:
			result.after = d["after"]
		return result
	