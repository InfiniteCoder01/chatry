@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchUpdateChannelGuestStarSettings
	


## 
## #/components/schemas/UpdateChannelGuestStarSettingsBody
class Body extends TwitchData:

	## Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot.
	@export var is_moderator_send_live_enabled: bool:
		set(val): 
			is_moderator_send_live_enabled = val
			track_data(&"is_moderator_send_live_enabled", val)
	
	## Number of slots the Guest Star call interface will allow the host to add to a call. Required to be between 1 and 6.
	@export var slot_count: int:
		set(val): 
			slot_count = val
			track_data(&"slot_count", val)
	
	## Flag determining if Browser Sources subscribed to sessions on this channel should output audio
	@export var is_browser_source_audio_enabled: bool:
		set(val): 
			is_browser_source_audio_enabled = val
			track_data(&"is_browser_source_audio_enabled", val)
	
	## This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:   
	##   
	## * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
	## * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
	## * `HORIZONTAL_LAYOUT`: All live guests are arranged in a horizontal bar within the browser source
	## * `VERTICAL_LAYOUT`: All live guests are arranged in a vertical bar within the browser source
	@export var group_layout: String:
		set(val): 
			group_layout = val
			track_data(&"group_layout", val)
	
	## Flag determining if Guest Star should regenerate the auth token associated with the channelâ€™s browser sources. Providing a true value for this will immediately invalidate all browser sources previously configured in your streaming software.
	@export var regenerate_browser_sources: bool:
		set(val): 
			regenerate_browser_sources = val
			track_data(&"regenerate_browser_sources", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create() -> Body:
		var body: Body = Body.new()
		return body
	
	
	static func from_json(d: Dictionary) -> Body:
		var result: Body = Body.new()
		if d.get("is_moderator_send_live_enabled", null) != null:
			result.is_moderator_send_live_enabled = d["is_moderator_send_live_enabled"]
		if d.get("slot_count", null) != null:
			result.slot_count = d["slot_count"]
		if d.get("is_browser_source_audio_enabled", null) != null:
			result.is_browser_source_audio_enabled = d["is_browser_source_audio_enabled"]
		if d.get("group_layout", null) != null:
			result.group_layout = d["group_layout"]
		if d.get("regenerate_browser_sources", null) != null:
			result.regenerate_browser_sources = d["regenerate_browser_sources"]
		return result
	