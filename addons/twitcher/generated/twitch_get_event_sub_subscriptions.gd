@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchGetEventSubSubscriptions
	


## 
## #/components/schemas/GetEventSubSubscriptionsResponse
class Response extends TwitchData:

	## The list of subscriptions. The list is ordered by the oldest subscription first. The list is empty if the client hasn't created subscriptions or there are no subscriptions that match the specified filter criteria.
	@export var data: Array[TwitchEventSubSubscription]:
		set(val): 
			data = val
			track_data(&"data", val)
	
	## The total number of subscriptions that you've created.
	@export var total: int:
		set(val): 
			total = val
			track_data(&"total", val)
	
	## The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	@export var total_cost: int:
		set(val): 
			total_cost = val
			track_data(&"total_cost", val)
	
	## The maximum total cost that you're allowed to incur for all subscriptions that you create.
	@export var max_total_cost: int:
		set(val): 
			max_total_cost = val
			track_data(&"max_total_cost", val)
	
	## An object that contains the cursor used to get the next page of subscriptions. The object is empty if there are no more pages to get. The number of subscriptions returned per page is undertermined.
	@export var pagination: ResponsePagination:
		set(val): 
			pagination = val
			track_data(&"pagination", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_data: Array[TwitchEventSubSubscription], _total: int, _total_cost: int, _max_total_cost: int) -> Response:
		var response: Response = Response.new()
		response.data = _data
		response.total = _total
		response.total_cost = _total_cost
		response.max_total_cost = _max_total_cost
		return response
	
	
	static func from_json(d: Dictionary) -> Response:
		var result: Response = Response.new()
		if d.get("data", null) != null:
			for value in d["data"]:
				result.data.append(TwitchEventSubSubscription.from_json(value))
		if d.get("total", null) != null:
			result.total = d["total"]
		if d.get("total_cost", null) != null:
			result.total_cost = d["total_cost"]
		if d.get("max_total_cost", null) != null:
			result.max_total_cost = d["max_total_cost"]
		if d.get("pagination", null) != null:
			result.pagination = ResponsePagination.from_json(d["pagination"])
		return result
	
	
	
	func _has_pagination() -> bool:
		if pagination == null: return false
		if pagination.cursor == null || pagination.cursor == "": return false
		return true
	
	var _next_page: Callable
	var _cur_iter: int = 0
	
	
	func next_page() -> Response:
		var response: Response = await _next_page.call()
		_cur_iter = 0
		_next_page = response._next_page
		data = response.data
		total = response.total
		total_cost = response.total_cost
		max_total_cost = response.max_total_cost
		pagination = response.pagination
	
		return response
	
	
	func _iter_init(iter: Array) -> bool:
		if data.is_empty(): return false
		iter[0] = data[0]
		return data.size() > 0
		
		
	func _iter_next(iter: Array) -> bool:
		if data.size() - 1 > _cur_iter:
			_cur_iter += 1
			iter[0] = data[_cur_iter]
		if data.size() - 1 == _cur_iter && not _has_pagination(): 
			return false
		return true
		
		
	func _iter_get(iter: Variant) -> Variant:
		if data.size() - 1 == _cur_iter && _has_pagination():
			await next_page()
		return iter


## An object that contains the cursor used to get the next page of subscriptions. The object is empty if there are no more pages to get. The number of subscriptions returned per page is undertermined.
## #/components/schemas/GetEventSubSubscriptionsResponse/Pagination
class ResponsePagination extends TwitchData:

	## The cursor value that you set the _after_ query parameter to.
	@export var cursor: String:
		set(val): 
			cursor = val
			track_data(&"cursor", val)
	
	
	
	## Constructor with all required fields.
	static func create() -> ResponsePagination:
		var response_pagination: ResponsePagination = ResponsePagination.new()
		return response_pagination
	
	
	static func from_json(d: Dictionary) -> ResponsePagination:
		var result: ResponsePagination = ResponsePagination.new()
		if d.get("cursor", null) != null:
			result.cursor = d["cursor"]
		return result
	