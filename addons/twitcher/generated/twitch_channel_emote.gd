@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

## 
## #/components/schemas/ChannelEmote
class_name TwitchChannelEmote
	
## An ID that identifies this emote.
@export var id: String:
	set(val): 
		id = val
		track_data(&"id", val)

## The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
@export var name: String:
	set(val): 
		name = val
		track_data(&"name", val)

## The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.  
##   
## **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
@export var images: Images:
	set(val): 
		images = val
		track_data(&"images", val)

## The subscriber tier at which the emote is unlocked. This field contains the tier information only if `emote_type` is set to `subscriptions`, otherwise, it's an empty string.
@export var tier: String:
	set(val): 
		tier = val
		track_data(&"tier", val)

## The type of emote. The possible values are:  
##   
## * bitstier — A custom Bits tier emote.
## * follower — A custom follower emote.
## * subscriptions — A custom subscriber emote.
@export var emote_type: String:
	set(val): 
		emote_type = val
		track_data(&"emote_type", val)

## An ID that identifies the emote set that the emote belongs to.
@export var emote_set_id: String:
	set(val): 
		emote_set_id = val
		track_data(&"emote_set_id", val)

## The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:  
##   
## * animated — An animated GIF is available for this emote.
## * static — A static PNG file is available for this emote.
@export var format: Array[String]:
	set(val): 
		format = val
		track_data(&"format", val)

## The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:  
##   
## * 1.0 — A small version (28px x 28px) is available.
## * 2.0 — A medium version (56px x 56px) is available.
## * 3.0 — A large version (112px x 112px) is available.
@export var scale: Array[String]:
	set(val): 
		scale = val
		track_data(&"scale", val)

## The background themes that the emote is available in. Possible themes are:  
##   
## * dark
## * light
@export var theme_mode: Array[String]:
	set(val): 
		theme_mode = val
		track_data(&"theme_mode", val)
var response: BufferedHTTPClient.ResponseData


## Constructor with all required fields.
static func create(_id: String, _name: String, _images: Images, _tier: String, _emote_type: String, _emote_set_id: String, _format: Array[String], _scale: Array[String], _theme_mode: Array[String]) -> TwitchChannelEmote:
	var twitch_channel_emote: TwitchChannelEmote = TwitchChannelEmote.new()
	twitch_channel_emote.id = _id
	twitch_channel_emote.name = _name
	twitch_channel_emote.images = _images
	twitch_channel_emote.tier = _tier
	twitch_channel_emote.emote_type = _emote_type
	twitch_channel_emote.emote_set_id = _emote_set_id
	twitch_channel_emote.format = _format
	twitch_channel_emote.scale = _scale
	twitch_channel_emote.theme_mode = _theme_mode
	return twitch_channel_emote


static func from_json(d: Dictionary) -> TwitchChannelEmote:
	var result: TwitchChannelEmote = TwitchChannelEmote.new()
	if d.get("id", null) != null:
		result.id = d["id"]
	if d.get("name", null) != null:
		result.name = d["name"]
	if d.get("images", null) != null:
		result.images = Images.from_json(d["images"])
	if d.get("tier", null) != null:
		result.tier = d["tier"]
	if d.get("emote_type", null) != null:
		result.emote_type = d["emote_type"]
	if d.get("emote_set_id", null) != null:
		result.emote_set_id = d["emote_set_id"]
	if d.get("format", null) != null:
		for value in d["format"]:
			result.format.append(value)
	if d.get("scale", null) != null:
		for value in d["scale"]:
			result.scale.append(value)
	if d.get("theme_mode", null) != null:
		for value in d["theme_mode"]:
			result.theme_mode.append(value)
	return result



## The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.  
##   
## **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
## #/components/schemas/ChannelEmote/Images
class Images extends TwitchData:

	## A URL to the small version (28px x 28px) of the emote.
	@export var url_1x: String:
		set(val): 
			url_1x = val
			track_data(&"url_1x", val)
	
	## A URL to the medium version (56px x 56px) of the emote.
	@export var url_2x: String:
		set(val): 
			url_2x = val
			track_data(&"url_2x", val)
	
	## A URL to the large version (112px x 112px) of the emote.
	@export var url_4x: String:
		set(val): 
			url_4x = val
			track_data(&"url_4x", val)
	
	
	
	## Constructor with all required fields.
	static func create(_url_1x: String, _url_2x: String, _url_4x: String) -> Images:
		var images: Images = Images.new()
		images.url_1x = _url_1x
		images.url_2x = _url_2x
		images.url_4x = _url_4x
		return images
	
	
	static func from_json(d: Dictionary) -> Images:
		var result: Images = Images.new()
		if d.get("url_1x", null) != null:
			result.url_1x = d["url_1x"]
		if d.get("url_2x", null) != null:
			result.url_2x = d["url_2x"]
		if d.get("url_4x", null) != null:
			result.url_4x = d["url_4x"]
		return result
	