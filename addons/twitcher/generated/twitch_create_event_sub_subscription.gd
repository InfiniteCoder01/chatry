@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchCreateEventSubSubscription
	


## 
## #/components/schemas/CreateEventSubSubscriptionBody
class Body extends TwitchData:

	## The type of subscription to create. For a list of subscriptions that you can create, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). Set this field to the value in the **Name** column of the Subscription Types table.
	@export var type: String:
		set(val): 
			type = val
			track_data(&"type", val)
	
	## The version number that identifies the definition of the subscription type that you want the response to use.
	@export var version: String:
		set(val): 
			version = val
			track_data(&"version", val)
	
	## A JSON object that contains the parameter values that are specific to the specified subscription type. For the object’s required and optional fields, see the subscription type’s documentation.
	@export var condition: Dictionary:
		set(val): 
			condition = val
			track_data(&"condition", val)
	
	## The transport details that you want Twitch to use when sending you notifications.
	@export var transport: BodyTransport:
		set(val): 
			transport = val
			track_data(&"transport", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_type: String, _version: String, _condition: Dictionary, _transport: BodyTransport) -> Body:
		var body: Body = Body.new()
		body.type = _type
		body.version = _version
		body.condition = _condition
		body.transport = _transport
		return body
	
	
	static func from_json(d: Dictionary) -> Body:
		var result: Body = Body.new()
		if d.get("type", null) != null:
			result.type = d["type"]
		if d.get("version", null) != null:
			result.version = d["version"]
		if d.get("condition", null) != null:
			result.condition = d["condition"]
		if d.get("transport", null) != null:
			result.transport = BodyTransport.from_json(d["transport"])
		return result
	


## The transport details that you want Twitch to use when sending you notifications.
## #/components/schemas/CreateEventSubSubscriptionBody/Transport
class BodyTransport extends TwitchData:

	## The transport method. Possible values are:  
	##   
	## * webhook
	## * websocket
	## * conduit
	@export var method: String:
		set(val): 
			method = val
			track_data(&"method", val)
	
	## The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See [Processing an event](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#processing-an-event). Specify this field only if `method` is set to **webhook**.
	## 
	## **NOTE**: Redirects are not followed.
	@export var callback: String:
		set(val): 
			callback = val
			track_data(&"callback", val)
	
	## The secret used to verify the signature. The secret must be an ASCII string that’s a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see [Verifying the event message](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#verifying-the-event-message). Specify this field only if `method` is set to **webhook**.
	@export var secret: String:
		set(val): 
			secret = val
			track_data(&"secret", val)
	
	## An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message. Specify this field only if `method` is set to **websocket**.
	@export var session_id: String:
		set(val): 
			session_id = val
			track_data(&"session_id", val)
	
	## An ID that identifies the conduit to send notifications to. When you create a conduit, the server returns the conduit ID. Specify this field only if `method` is set to **conduit**.
	@export var conduit_id: String:
		set(val): 
			conduit_id = val
			track_data(&"conduit_id", val)
	
	
	
	## Constructor with all required fields.
	static func create(_method: String) -> BodyTransport:
		var body_transport: BodyTransport = BodyTransport.new()
		body_transport.method = _method
		return body_transport
	
	
	static func from_json(d: Dictionary) -> BodyTransport:
		var result: BodyTransport = BodyTransport.new()
		if d.get("method", null) != null:
			result.method = d["method"]
		if d.get("callback", null) != null:
			result.callback = d["callback"]
		if d.get("secret", null) != null:
			result.secret = d["secret"]
		if d.get("session_id", null) != null:
			result.session_id = d["session_id"]
		if d.get("conduit_id", null) != null:
			result.conduit_id = d["conduit_id"]
		return result
	


## 
## #/components/schemas/CreateEventSubSubscriptionResponse
class Response extends TwitchData:

	## A list that contains the single subscription that you created.
	@export var data: Array[TwitchEventSubSubscription]:
		set(val): 
			data = val
			track_data(&"data", val)
	
	## The total number of subscriptions you’ve created.
	@export var total: int:
		set(val): 
			total = val
			track_data(&"total", val)
	
	## The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	@export var total_cost: int:
		set(val): 
			total_cost = val
			track_data(&"total_cost", val)
	
	## The maximum total cost that you’re allowed to incur for all subscriptions you create.
	@export var max_total_cost: int:
		set(val): 
			max_total_cost = val
			track_data(&"max_total_cost", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_data: Array[TwitchEventSubSubscription], _total: int, _total_cost: int, _max_total_cost: int) -> Response:
		var response: Response = Response.new()
		response.data = _data
		response.total = _total
		response.total_cost = _total_cost
		response.max_total_cost = _max_total_cost
		return response
	
	
	static func from_json(d: Dictionary) -> Response:
		var result: Response = Response.new()
		if d.get("data", null) != null:
			for value in d["data"]:
				result.data.append(TwitchEventSubSubscription.from_json(value))
		if d.get("total", null) != null:
			result.total = d["total"]
		if d.get("total_cost", null) != null:
			result.total_cost = d["total_cost"]
		if d.get("max_total_cost", null) != null:
			result.max_total_cost = d["max_total_cost"]
		return result
	