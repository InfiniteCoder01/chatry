@tool
extends TwitchData

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchGetConduitShards
	


## 
## #/components/schemas/GetConduitShardsResponse
class Response extends TwitchData:

	## List of information about a conduit's shards.
	@export var data: Array[ResponseData]:
		set(val): 
			data = val
			track_data(&"data", val)
	
	## Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
	@export var pagination: ResponsePagination:
		set(val): 
			pagination = val
			track_data(&"pagination", val)
	var response: BufferedHTTPClient.ResponseData
	
	
	## Constructor with all required fields.
	static func create(_data: Array[ResponseData]) -> Response:
		var response: Response = Response.new()
		response.data = _data
		return response
	
	
	static func from_json(d: Dictionary) -> Response:
		var result: Response = Response.new()
		if d.get("data", null) != null:
			for value in d["data"]:
				result.data.append(ResponseData.from_json(value))
		if d.get("pagination", null) != null:
			result.pagination = ResponsePagination.from_json(d["pagination"])
		return result
	
	
	
	func _has_pagination() -> bool:
		if pagination == null: return false
		if pagination.cursor == null || pagination.cursor == "": return false
		return true
	
	var _next_page: Callable
	var _cur_iter: int = 0
	
	
	func next_page() -> Response:
		var response: Response = await _next_page.call()
		_cur_iter = 0
		_next_page = response._next_page
		data = response.data
		pagination = response.pagination
	
		return response
	
	
	func _iter_init(iter: Array) -> bool:
		if data.is_empty(): return false
		iter[0] = data[0]
		_cur_iter = 1
		return true
		
		
	func _iter_next(iter: Array) -> bool:
		if data.size() > _cur_iter:
			iter[0] = data[_cur_iter]
			_cur_iter += 1
		elif not _has_pagination(): 
			return false
		return true
		
		
	func _iter_get(iter: Variant) -> Variant:
		if data.size() - 1 == _cur_iter && _has_pagination():
			await next_page()
		return iter


## List of information about a conduit's shards.
## #/components/schemas/GetConduitShardsResponse/Data
class ResponseData extends TwitchData:

	## Shard ID.
	@export var id: String:
		set(val): 
			id = val
			track_data(&"id", val)
	
	## The shard status. The subscriber receives events only for enabled shards. Possible values are:  
	##   
	## * enabled — The shard is enabled.
	## * webhook\_callback\_verification\_pending — The shard is pending verification of the specified callback URL.
	## * webhook\_callback\_verification\_failed — The specified callback URL failed verification.
	## * notification\_failures\_exceeded — The notification delivery failure rate was too high.
	## * websocket\_disconnected — The client closed the connection.
	## * websocket\_failed\_ping\_pong — The client failed to respond to a ping message.
	## * websocket\_received\_inbound\_traffic — The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	## * websocket\_internal\_error — The Twitch WebSocket server experienced an unexpected error.
	## * websocket\_network\_timeout — The Twitch WebSocket server timed out writing the message to the client.
	## * websocket\_network\_error — The Twitch WebSocket server experienced a network error writing the message to the client.
	## * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	@export var status: String:
		set(val): 
			status = val
			track_data(&"status", val)
	
	## The transport details used to send the notifications.
	@export var transport: ResponseTransport:
		set(val): 
			transport = val
			track_data(&"transport", val)
	
	
	
	## Constructor with all required fields.
	static func create(_id: String, _status: String, _transport: ResponseTransport) -> ResponseData:
		var response_data: ResponseData = ResponseData.new()
		response_data.id = _id
		response_data.status = _status
		response_data.transport = _transport
		return response_data
	
	
	static func from_json(d: Dictionary) -> ResponseData:
		var result: ResponseData = ResponseData.new()
		if d.get("id", null) != null:
			result.id = d["id"]
		if d.get("status", null) != null:
			result.status = d["status"]
		if d.get("transport", null) != null:
			result.transport = ResponseTransport.from_json(d["transport"])
		return result
	


## The transport details used to send the notifications.
## #/components/schemas/GetConduitShardsResponse/Data/Transport
class ResponseTransport extends TwitchData:

	## The transport method. Possible values are:  
	##   
	## * webhook
	## * websocket
	@export var method: String:
		set(val): 
			method = val
			track_data(&"method", val)
	
	## The callback URL where the notifications are sent. Included only if method is set to webhook.
	@export var callback: String:
		set(val): 
			callback = val
			track_data(&"callback", val)
	
	## An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
	@export var session_id: String:
		set(val): 
			session_id = val
			track_data(&"session_id", val)
	
	## The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
	@export var connected_at: String:
		set(val): 
			connected_at = val
			track_data(&"connected_at", val)
	
	## The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
	@export var disconnected_at: String:
		set(val): 
			disconnected_at = val
			track_data(&"disconnected_at", val)
	
	
	
	## Constructor with all required fields.
	static func create(_method: String) -> ResponseTransport:
		var response_transport: ResponseTransport = ResponseTransport.new()
		response_transport.method = _method
		return response_transport
	
	
	static func from_json(d: Dictionary) -> ResponseTransport:
		var result: ResponseTransport = ResponseTransport.new()
		if d.get("method", null) != null:
			result.method = d["method"]
		if d.get("callback", null) != null:
			result.callback = d["callback"]
		if d.get("session_id", null) != null:
			result.session_id = d["session_id"]
		if d.get("connected_at", null) != null:
			result.connected_at = d["connected_at"]
		if d.get("disconnected_at", null) != null:
			result.disconnected_at = d["disconnected_at"]
		return result
	


## Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
## #/components/schemas/GetConduitShardsResponse/Pagination
class ResponsePagination extends TwitchData:

	## The cursor used to get the next page of results. Use the cursor to set the request’s after query parameter.
	@export var cursor: String:
		set(val): 
			cursor = val
			track_data(&"cursor", val)
	
	
	
	## Constructor with all required fields.
	static func create() -> ResponsePagination:
		var response_pagination: ResponsePagination = ResponsePagination.new()
		return response_pagination
	
	
	static func from_json(d: Dictionary) -> ResponsePagination:
		var result: ResponsePagination = ResponsePagination.new()
		if d.get("cursor", null) != null:
			result.cursor = d["cursor"]
		return result
	


## All optional parameters for TwitchAPI.get_conduit_shards
## #/components/schemas/GetConduitShardsOpt
class Opt extends TwitchData:

	## Status to filter by.
	@export var status: String:
		set(val): 
			status = val
			track_data(&"status", val)
	
	## The cursor used to get the next page of results. The pagination object in the response contains the cursor’s value.
	@export var after: String:
		set(val): 
			after = val
			track_data(&"after", val)
	
	
	
	## Constructor with all required fields.
	static func create() -> Opt:
		var opt: Opt = Opt.new()
		return opt
	
	
	static func from_json(d: Dictionary) -> Opt:
		var result: Opt = Opt.new()
		if d.get("status", null) != null:
			result.status = d["status"]
		if d.get("after", null) != null:
			result.after = d["after"]
		return result
	